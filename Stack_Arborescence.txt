ğŸ“‚ Arborescence du Projet "VEV RAG"

vev_rag/
â”‚
â”œâ”€â”€ ğŸ“ data/                   # Stockage des donnÃ©es (exclu du Git via .gitignore)
â”‚   â”œâ”€â”€ ğŸ“ raw/                # Documents bruts (PDF, DOCX) dÃ©posÃ©s ici
â”‚   â”œâ”€â”€ ğŸ“ processed/          # Fichiers Markdown intermÃ©diaires (sortie Docling)
â”‚   â””â”€â”€ ğŸ“ lancedb/            # La base de donnÃ©es vectorielle (fichiers .lance)
â”‚
â”œâ”€â”€ ğŸ“ models/                 # ModÃ¨les IA locaux (GGUF, ONNX)
â”‚   â”œâ”€â”€ ğŸ“ llm/                # ex: qwen2.5-3b-instruct-q4_k_m.gguf
â”‚   â””â”€â”€ ğŸ“ embeddings/         # Cache FastEmbed / BGE-M3 (gÃ©rÃ© auto, mais bon Ã  savoir)
â”‚
â”œâ”€â”€ ğŸ“ src/                    # Code source de l'application
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ ğŸ“ core/               # Configuration et types de base
â”‚   â”‚   â”œâ”€â”€ config.py          # ParamÃ¨tres (chemins, noms modÃ¨les)
â”‚   â”‚   â””â”€â”€ schemas.py         # Classes Pydantic (Document, Chunk, SearchResult)
â”‚   â”‚
â”‚   â”œâ”€â”€ ğŸ“ ingestion/          # Phase 1 : EntrÃ©e des donnÃ©es
â”‚   â”‚   â”œâ”€â”€ loader_doc.py      # Logique Docling (PDF/Word -> MD)
â”‚   â”‚   â”œâ”€â”€ loader_web.py      # Logique Trafilatura (URL -> Txt)
â”‚   â”‚   â””â”€â”€ cleaner.py         # ftfy + regex + spacy (Normalisation)
â”‚   â”‚
â”‚   â”œâ”€â”€ ğŸ“ indexing/           # Phase 2 : Vectorisation
â”‚   â”‚   â”œâ”€â”€ chunker.py         # Semantic Chunking logic
â”‚   â”‚   â”œâ”€â”€ embedder.py        # Wrapper FastEmbed + BGE-M3
â”‚   â”‚   â””â”€â”€ vector_store.py    # Gestion LanceDB (create table, add, search)
â”‚   â”‚
â”‚   â”œâ”€â”€ ğŸ“ retrieval/         # Phase 3 : Recherche
â”‚   â”‚   â”œâ”€â”€ cache.py           # Logique GPTCache
â”‚   â”‚   â”œâ”€â”€ query_expansion.   # Logique HyDE / Multi-Query
â”‚   â”‚   â””â”€â”€ reranker.py        # Logique MXBai V2
â”‚   â”‚
â”‚   â”œâ”€â”€ ğŸ“ generation/        # Phase 4 : LLM
â”‚   â”‚   â”œâ”€â”€ llm_engine.py      # Chargement Llama.cpp / Qwen
â”‚   â”‚   â””â”€â”€ system_prompts.py  # Templates de prompts (SystÃ¨me, User)
â”‚   â”‚
â”‚   â””â”€â”€ ğŸ“ evaluation/        # Phase 5 : Tests
â”‚       â””â”€â”€ ragas_eval.py      # Script d'Ã©valuation RAGAS
â”‚
â”œâ”€â”€ ğŸ“ tests/                 # Tests unitaires classiques (pytest)
â”‚   â”œâ”€â”€ test_ingestion.py
â”‚   â””â”€â”€ test_retrieval.py
â”‚
â”œâ”€â”€ .env                            # Variables d'environnement (API keys si besoin, configs)
â”œâ”€â”€ .gitignore                      # Ignorer data/, models/, .env, __pycache__
â”œâ”€â”€ main.py                         # Point d'entrÃ©e CLI (pour lancer l'ingestion ou le chat terminal)
â”œâ”€â”€ app.py                          # Interface Streamlit ou FastAPI
â”œâ”€â”€ requirements.txt                # Liste des dÃ©pendances (docling, lancedb, fastembed, etc.)
â””â”€â”€ README.md                       # Documentation du projet VEV


ğŸ’¡ Pourquoi cette structure ?

SÃ©paration des responsabilitÃ©s (src/) :

Chaque dossier correspond Ã  une Ã©tape de votre tableau comparatif. Si vous voulez changer de modÃ¨le d'embedding, vous touchez uniquement Ã  src/indexing/embedder.py. Le reste du code ne bouge pas.

Gestion des donnÃ©es (data/ et models/) :

On sÃ©pare clairement le code des gros fichiers binaires (GGUF, Index LanceDB) pour ne pas polluer votre gestionnaire de version (Git).

Typage centralisÃ© (core/schemas.py) :

C'est ici que vous dÃ©finirez vos objets Dataclass ou Pydantic. Tous les modules importeront ces dÃ©finitions pour garantir qu'un "Document" a toujours la mÃªme forme du dÃ©but Ã  la fin.
